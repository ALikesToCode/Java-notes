**Week 9: Mastering Concurrency and Data Handling in Java**

**Introduction:**

Welcome to Week 9, where we delve into two powerful and intertwined concepts in Java: concurrency and advanced data handling. In this module, we'll tackle challenges related to working with multiple threads and efficiently managing diverse data structures, moving beyond basic operations and delving into some of Java's core features for building more robust and scalable applications. 

**Module 1: Understanding Optional Types**

**1.1 The Problem: Handling the Absence of Data**

In many programs, operations might fail to produce a value. Instead of returning a “null” value, which can cause NullPointerExceptions, Java introduces *Optional* types. Let’s consider a scenario. You are processing data from an API that provides user details. Sometimes the API might not have some specific details for a particular user, such as their address. 

Returning `null` values creates challenges:*   **NullPointerException:** If the program assumes a value is present and tries to access methods or properties of the `null`, then it throws a NullPointerException, causing the program to crash.*   **Code Clutter:** You must add explicit `null` checks to prevent the exceptions, making the code verbose.

**1.2 The Solution: Introducing `Optional<T>`**

Java provides `Optional<T>` as a container object that may or may not contain a non-null value. `T` represents the type of value that could be stored inside. Using `Optional<T>`, we can be more expressive about the possibility of a missing value and it becomes part of the API.

Key Concepts:*   **Wrapper Object:** Optional is a container or a wrapper for a value of a specific type.*   **State of an Optional**: An Optional instance can be in one of the two states - Value is present or value is absent (empty).*   **Type-Safe Handling:** Optional enforces type safety because if we define the API returns Optional, then we can only access it through the methods of optional and not just the contained value.

**1.3  Dealing with Empty Streams**

A common area where Optional values are used in Java is with Streams, particularly with terminal operations such as `max()` and `min()`. When applied to an empty stream, there isn't a maximum or minimum value.

Example:```java
Optional<Double> maxrand =
        Stream.generate(Math::random)
        .limit(100)
        .filter(n -> n < 0.001)
        .max(Double::compareTo);
```In the code above, the filter might eliminate all elements, resulting in an empty stream. In this case, the method `max()` does not produce a `Double` but an `Optional<Double>` object which might or might not contain a value.  What if we simply want a `double` value?

**1.4 Handling Missing Optional Values**

Here’s how we deal with missing Optional values:

*   **orElse(T other):**    - If a value is present in the Optional object, it returns that value.    - If the Optional is empty, it returns the specified “other” value as a default.    - Good for simple cases where you have a fallback value, eg: default value.    ```java
    Double fixrand = maxrand.orElse(-1.0); // returns -1.0 if maxrand is empty
    ```*   **orElseGet(Supplier<? extends T> supplier):**    -   Similar to orElse, but it accepts a function (`Supplier`) which generates the replacement if the Optional is empty.    -   This allows for more complex default value generation.    -   Use case: when your fallback is costly to compute.    ```java
    Double fixrand = maxrand.orElseGet(
             () -> SomeFunctionToGenerateDouble()
          );
    ```*   **orElseThrow(Supplier<? extends X> exceptionSupplier):**    - If the value is present, it returns the value.    - If the Optional is empty, it throws an exception generated by the provided supplier.    - Use case: when you want to signal a missing value as an exception.     ```java
    Double fixrand = maxrand.orElseThrow(
        IllegalStateException::new
      );
    ```

**1.5 Ignoring Missing Optional Values**

Often you might want to check if an optional is present and perform some actions, without using if-else kind of constructs. Here are a few ways to do this:

*   **ifPresent(Consumer<? super T> action):**    - If value is present, it performs the given action.    - Good for side effects that are not necessary for program execution.    ```java
     optionalValue.ifPresent (v -> Process v); // only process if value is present.
    ```

*   **Adding to a Collection using ifPresent:**    - If you have to add a value to a collection, only if it is present in the optional:    ```java
    Optional<Double> maxrand =
       Stream.generate(Math::random)
       .limit(100)
       .filter(n -> n < 0.001)
       .max(Double::compareTo);
    
    var results = new ArrayList<Double>();
    maxrand.ifPresent (v -> results.add(v));
    
    //Using method reference:
    maxrand.ifPresent (results::add);
    ```    *   **Alternative Action if the Value is not Present:**  - ifPresentOrElse() handles both cases of presence and absence.    ```java
   Optional<Double> maxrand =
       Stream.generate(Math::random)
       .limit(100)
       .filter(n -> n < 0.001)
       .max(Double::compareTo);
    
   var results = new ArrayList<Double>();
   maxrand.ifPresentOrElse(
     v -> results.add(v),
     () -> System.out.println("No max")
   );
    ```

**1.6 Creating Optional Values**

There are different ways to construct optional objects:

*   **Optional.of(T value):**    - Creates a new Optional object that contains a specified value    -   Throws a `NullPointerException` if the value is null    ```java
     Optional<Double>  val = Optional.of(2.5);
    ```

*   **Optional.empty():**    - Creates an empty Optional instance, representing an absent value.    ```java
    Optional<String>  str = Optional.empty();
    ```*    **Optional.ofNullable(T value):**    -   Creates an Optional instance, but is null-tolerant. If the value is null, it returns an empty Optional. If not, it returns the optional wrapping the value.    -   Useful when interfacing with legacy code that may return null values.    ```java
     Optional<Double>  val = Optional.ofNullable(myFunc()); // myFunc might return null
    ```

**1.7 Passing On Optional Values**

Sometimes we want to chain operations on an Optional value, but also preserving the optional. We can do it with the following:

*   **map(Function<? super T, ? extends U> mapper):**     -  Applies the mapping function to the value if it is present and returns an optional of the result.     -   Returns an empty Optional if the original Optional was empty.     -   This enables us to chain operations that return optional and preserve the Optional object.     ```java
       Optional<Double> maxrand = ...;
       Optional<Double> maxrandasqr = maxrand.map(v -> v*v); // will only execute if maxrand is not empty.
    ```*   **Another Example:**

 ```java
    Optional<Double> maxrand = ...;
    var results = new ArrayList<Double>();
    maxrand.map(results::add);
 ```

*   **or() Method**

   - If a value is present, it will be passed as it is.   - If value is empty, then value generated by or() is passed.```java
Optional<Double> maxrand = ...;
Optional<Double> fixrand =
maxrand.or(() -> Optional.of(-1.0));
```

**1.8 Composing Optional Values**

*   **flatMap(Function<? super T, ? extends Optional<? extends U>> mapper):**    -  If you have a function, which returns an optional and the input is again an optional, then map won't work.    - flatMap transforms the optional value but also flattens the nested Optionals which arise from the mapping.    -  If you are calling a method like f() which returns Optional, and class T defines method g which returns optional then you should apply flat map and not just map to combine them, to avoid nested optionals.   - Use case: calling functions that return optionals and avoiding nested optionals.    ```java
     Optional<U> result = s.f().flatMap(T::g);
    ```

*   **Example**

   - Suppose that you have the inverse function which returns an optional. And you want to pass that to another function called sqrt, which also returns an optional. Then you can use the above flat map to chain the operations.   - Use case: Calling functions that return optional one after the other.

 ```java
public static Optional<Double> inverse (Double x) {
    if(x == 0) {
        return Optional.empty();
    } else {
        return Optional.of(1/x);
    }
}

public static Optional<Double> squareRoot (Double x) {
    if(x < 0) {
        return Optional.empty();
    } else {
        return Optional.of(Math.sqrt(x));
    }
}

Optional<Double> result = inverse(x).flatMap(MyClass::squareRoot);
```**1.9 Turning an Optional into a Stream***   **flatMap(Function<? super T, ? extends Stream<? extends U>> mapper):**   - A common case of composing optionals is to convert an optional into a stream.   - If a lookup function returns a User based on the id, if it is a valid username, then you can use flatMap to map this into a Stream of Users based on multiple ids.```java
Optional<User> lookup(String id) { ... };

Stream<String> ids = ...;
Stream<User> users = ids.map(Users::lookup) // returns a stream of optional users
      .flatMap(Optional::stream); // converts the optional values to stream of users
```*   **Using ofNullable if `lookup` did not return Optional:**   - Use this function if the original code returned null instead of optional.

```java
    User oldLookup(String id) {... }; // might return user or null
Stream<String> ids = ...;
Stream<User> users = ids.flatMap(
        id -> Stream.ofNullable(
            Users.oldLookup(id)
        )
    );

```**Module 2: Collecting Results from Streams**

**2.1 From Collections to Streams, and Back Again:**We've learned that it's easy to convert collections to streams and process sequences of elements, but often we need to convert a stream back into a collection.

**2.2 Processing a Stream as a Collection:**

*   **Standard Iterator:**  The `Stream` interface itself defines a standard iterator, allowing traversal using a loop:```java
    Stream<String> mystream = ...;
    mystream.forEach(System.out::println); // use to loop through values in a stream
```*   **Using `forEach()`:** You can use forEach with a function to iterate over the stream: ```java
     mystream.forEach (System.out::println); // using method reference
 ```*   **Converting to Array:** To store values in an array:  - Create a standard object array (type becomes `Object[]` )    ```java
         Object[] result = mystream.toArray();
    ```  - Create an array of a specific type  ```java
      String[] result = mystream.toArray(String[]::new);
      //mystream.toArray() has the type Object[]
  ```

**2.3 Storing a Stream as a Collection:**

*  **Using collect():**    - Use the collect method to obtain a List or Set etc from the Stream    - It uses  factory methods from Collectors for this

*   **Create a List from a stream:**  ```java
     List<String> result = mystream.collect(Collectors.toList());
  ```*   **Create a Set from a Stream:**   ```java
      Set<String> result = mystream.collect(Collectors.toSet());
  ```*   **Create a Concrete Collection using a Constructor:**    -To create a concrete collection, use Collectors.toCollection() method. You need to provide a constructor for your collection object.     ```java
          TreeSet<String> result = stream.collect(
               Collectors.toCollection(TreeSet::new)
          );
      ```**2.4 Stream Summaries**   - We saw ways to reduce stream into a single result value such as count, max, min.   - However, Collectors also provide summaries to collect multiple results as a single object.*   **Using `summarizingInt()`:**  -  Use summarizingInt when you want to obtain several numeric properties of a stream of integers.   - You need a function which will map the stream elements to the required integer.  -   It returns an `IntSummaryStatistics` object```java
       IntSummaryStatistics summary =
         mystream.collect(
            Collectors.summarizingInt(String::length)
         );
      double averageWordLength = summary.getAverage();
      double maxwWordLength = summary.getMax();
```*   **Methods on Summary Statistics**: You can use the following methods to access relevant properties from the returned summary object  -  `getCount()`
   - `getMax()`
  -  `getMin()`
   - `getSum()`
    -`getAverage()`

*  Similarly `summarizingLong` and `summarizingDouble` are available which will return LongSummaryStatistics and DoubleSummaryStatistics and has the similar accessors.

**2.5 Converting a Stream to a Map**

Sometimes, you want to convert your stream of object to a Map. Then you can use Collectors.toMap() method.

*   **toMap(Function keyMapper, Function valueMapper):**    - The basic syntax is to provide a key mapper and a value mapper function.    - If your stream contains objects of type `Person`, and the keys should be ids and values should be names, then you can create a map as follows.```java
 Stream<Person> people = ...;
Map<Integer, String> idToName = people.collect(
            Collectors.toMap(
              Person::getId,
              Person::getName
           )
);
```   - You can use any valid object for key and value, and not necessarily String and integers.*   **Using Function Identity:** If you want to the whole object as the value.```java
  Stream<Person> people = ...;
  Map<Integer, Person> idToPerson = people.collect(
           Collectors.toMap(
             Person::getId,
              Function.identity()
            )
   );
```

*   **Handling Duplicate Keys:**   -   If you have duplicate keys during mapping, you will get an `IllegalStateException`.   -   If you are going to use the name as a key and ID as a value, then you might encounter the following error.

 ```java
Stream<Person> people = ...;
Map<String, Integer> nameToID =
people.collect(
         Collectors.toMap(
               Person::getName,
               Person::getId
         )
  ); // Will throw exception
```

*   **Using merge function to handle duplicates:**   - You can provide a function to handle if you are having a duplicate key.   - Here in the following example we are using the existing values for a duplicate key.

  ```java
    Stream<Person> people = ...;
    Map<String, Integer> nameToID =
        people.collect(
          Collectors.toMap(
             Person::getName,
            Person::getId,
            (existingValue, newValue) -> existingValue
         )
      );
 ```

**2.6 Grouping and Partitioning Values**

Sometimes, you want to split your stream into groups. This could be two different kind of grouping.

*   **Grouping by Key (groupingBy(Function classifier)):**    - Instead of discarding values with duplicate keys, group them.    - Collect all ids with the same name in a list.   ```java
     Stream<Person> people = ...;
      Map<String, List<Person>> nameToPersons =
           people.collect(
            Collectors.groupingBy(
            Person::getName
          )
       );
   ```*   **Partitioning using a Predicate(partitioningBy(Predicate predicate)):**    -  Instead, may want to partition the stream using a predicate.    -  Partition names into those that start with A and the rest.```java
Stream<Person> people = ...;
Map<Boolean, List<Person>> aAndOtherPersons =
 people.collect(
 Collectors.partitioningBy(
p -> p.getName().substr(0,1).equals("A")
       )
);
List<Person> startingLetterA = aAndOtherPersons.get(true);
```

**Module 3: Input/Output Streams**

**3.1 Understanding I/O Streams:**We use I/O streams to handle input or output with external sources, allowing our programs to interact with data in different forms.

*   **Input Streams:** Read a sequence of bytes from some source such as a file, an internet connection, or memory.*   **Output Streams:** Write a sequence of bytes to some source such as a file, an internet connection, or memory.*   **Data as Bytes:**  All data (text, numbers, multimedia) are represented internally as raw sequences of uninterpreted bytes. So the input and output are sequence of bytes.*   **Stream vs I/O Stream:** Importantly, the term ‘stream’ in I/O streams context differs from ‘stream’ as used in the `java.util.stream` API.  Stream class refers to a sequence of values that you are processing for some calculations etc.  I/O streams refers to raw bytes that you are reading or writing.

**3.2 Input/Output Values and Types**   - Input and Output values can be of different types including raw bytes, text or binary data.

  *  **Raw Bytes:** Input and output consist of raw, uninterpreted bytes of data.  *   **Text as Encoded Bytes:** Bytes can be interpreted as text using different Unicode encodings.  *   **Binary Data:**  Bytes can also represent binary data such as integers, floating-point numbers, doubles etc.

**3.3 Input and Output Transformations**

We often use transformers to process raw bytes. We can use a series of transformers, a pipeline:  -  Read raw bytes from a file, pass to a stream that reads text.  - Generate binary data, pass to a stream that writes raw bytes to a file.

**3.4 Reading and Writing Raw Bytes**

Java provides two essential classes for working directly with raw bytes:

*   **InputStream:**   -   Abstract class for reading bytes. Subclasses provide implementations for specific sources.   -   Abstract methods like  read() (reads single byte), read(byte[] b) (read a set of bytes into buffer), readAllBytes() (reads all the bytes).   -   It is a good practice to check the availability of the data using `available()` before attempting to read.   ```java
    InputStream in = ...;
    int bytesAvailable = in.available();
    if(bytesAvailable > 0) {
      var data = new byte[bytesAvailable];
      in.read(data);
    }
   ```

*   **OutputStream:**    - Abstract class for writing bytes, Subclasses provide implementations for specific sinks.    - Abstract methods like `write(int b)` (write single byte), write(byte[] b) (write a set of bytes from buffer).    -  To write a sequence of bytes from a byte array:    ```java
       OutputStream out = ...;
       byte[] values = ...;
        out.write(values);
        in.close();
    ```

**3.5 Important I/O Operations***   **Closing the Stream**: Always close a stream (both input and output) to release the resources by calling `close()` after the operations.*   **Flushing**: For output stream call flush() after writing to make sure the buffered data goes to the destination.

```java
 out.flush();
```

**3.6 Connecting a Stream to an External Source**

*   **FileInputStream:** To connect to an input file:

```java
var in = new FileInputStream("input.class");
```* **FileOutputStream:** To connect to an output file.  - To overwrite an existing file, provide `false` as a second argument to constructor:```java
var out = new FileOutputStream("newoutput.bin", false); // Overwrite
```  - To append to existing file, provide `true` as the second argument to constructor:```java
var out = new FileOutputStream("sameoutput.bin", true); // Append
```

**3.7 Reading and Writing Text***   **Scanner Class:**    - A versatile class for parsing text input.    - Can be applied to any InputStream.    -   Provides many read methods such as `nextLine()` (read one line), `next()` (read one word), `nextInt()` (read int) and `hasNext()`.  ```java
  var fin = new FileInputStream("input.txt");
  var scin = new Scanner(fin);
  String s = scin.nextLine(); // One line
  String w = scin.next(); // One word
  int i = scin.nextInt(); // Read an int
 boolean b = scin.hasNext(); // Any more words?
```*   **PrintWriter Class:**    - For writing text output.    -   Can be applied to any OutputStream.    - Provides methods such as  `println()` and `print()`.  ```java
       var fout = new FileOutputStream("output.txt");
       var pout = new PrintWriter(fout);
       String msg = "Hello, World!";
       pout.println(msg);
  ```

**3.8 Example: Copying Input Text File to Output Text File**```java
 var in = new Scanner(...);
 var out = new PrintWriter(...);
 while(in.hasNext()) {
   String line = in.nextLine();
    out.println(line);
 }
```

**3.9 Reading and Writing Binary Data**

*   **DataInputStream:** For reading binary data (int, short, float etc.)    -   Provides methods such as `readInt()`, `readShort()`, `readLong()`, `readFloat()`, `readDouble()`, `readChar()`, `readUTF()`, `readBoolean()`. ```java
 var fin = new FileInputStream("input.class");
 var din = new DataInputStream(fin);

  readInt, readShort, readLong
 readFloat, readDouble
 readChar, readUTF
 readBoolean
 ```*   **DataOutputStream:** For writing binary data (int, short, float etc)   -  Provides methods such as `writeInt()`, `writeShort()`, `writeLong()`, `writeFloat()`, `writeDouble()`, `writeChar()`, `writeUTF()`, `writeBoolean()`,  `writeChars()`, `writeByte()`.```java
  var fout = new FileOutputStream("output.bin");
 var dout = new DataOutputStream(fout);
   writeInt, writeShort, writeLong
 writeFloat, writeDouble
 writeChar, writeUTF
writeBoolean
writeChars, writeByte
```**3.10 Example: Copying Binary File to Another Binary File**```java
  var in = new DataInputStream(...);
  var out = new DataOutputStream(...);
  int bytesAvailable = in.available();
  while(bytesAvailable > 0) {
   var data = new byte[bytesAvailable];
   in.read(data);
    out.write(data);
    bytesAvailable = in.available();
}
```*    **Catching Exceptions**: It's vital to handle I/O exceptions in try-catch blocks because such operations can fail at run-time.

**3.11 Other Useful Features:**

*   **BufferedInputStream:**    - Buffering an input stream reads blocks of data and is more efficient.    -  Wrap FileInputStream with BufferedInputStream:    ```java
        var din = new DataInputStream(
                new BufferedInputStream(
                    new FileInputStream("grades.dat")
                )
           );
    ```*   **PushbackInputStream:**   - Offers speculative reads where you examine first element and return to stream if necessary.   - Read(), unread() methods. ```java
 var pbin = new PushbackInputStream(
        new BufferedInputStream(
            new FileInputStream("grades.dat")
        )
  );
 int b = pbin.read();
 if(b != '<') {
   pbin.unread(b);
 }
```

**3.12 Summary of Input/Output Streams**

*   Java's approach to input/output is to separate out concerns and we can chain together different types of input/output streams.*   We can read and write raw bytes, interpret raw bytes as text, or interpret raw bytes as data.*   There are techniques like buffering, speculative reads etc., which are more efficient.

**Module 4: Serialization**

**4.1 What is Serialization?**Serialization is the process of converting an object into a stream of bytes. Deserialization is the
